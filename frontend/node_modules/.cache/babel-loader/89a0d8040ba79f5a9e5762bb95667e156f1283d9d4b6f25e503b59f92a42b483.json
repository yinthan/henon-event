{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coordinateToTimeRatio = coordinateToTimeRatio;\nexports.calculateXPositionForTime = calculateXPositionForTime;\nexports.calculateTimeForXPosition = calculateTimeForXPosition;\nexports.iterateTimes = iterateTimes;\nexports.getMinUnit = getMinUnit;\nexports.getNextUnit = getNextUnit;\nexports.calculateInteractionNewTimes = calculateInteractionNewTimes;\nexports.calculateDimensions = calculateDimensions;\nexports.getGroupOrders = getGroupOrders;\nexports.getGroupedItems = getGroupedItems;\nexports.getVisibleItems = getVisibleItems;\nexports.collision = collision;\nexports.groupStack = groupStack;\nexports.groupNoStack = groupNoStack;\nexports.stackAll = stackAll;\nexports.stackGroup = stackGroup;\nexports.stackTimelineItems = stackTimelineItems;\nexports.getCanvasWidth = getCanvasWidth;\nexports.getItemDimensions = getItemDimensions;\nexports.getItemWithInteractions = getItemWithInteractions;\nexports.getCanvasBoundariesFromVisibleTime = getCanvasBoundariesFromVisibleTime;\nexports.calculateScrollCanvas = calculateScrollCanvas;\nexports.minCellWidth = void 0;\nvar _moment = _interopRequireDefault(require(\"moment\"));\nvar _generic = require(\"./generic\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    if (i % 2) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n/**\n * Calculate the ms / pixel ratio of the timeline state\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @returns {number}\n */\nfunction coordinateToTimeRatio(canvasTimeStart, canvasTimeEnd, canvasWidth) {\n  return (canvasTimeEnd - canvasTimeStart) / canvasWidth;\n}\n/**\n * For a given time, calculate the pixel position given timeline state\n * (timeline width in px, canvas time range)\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @param {number} time\n * @returns {number}\n */\n\nfunction calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, time) {\n  var widthToZoomRatio = canvasWidth / (canvasTimeEnd - canvasTimeStart);\n  var timeOffset = time - canvasTimeStart;\n  return timeOffset * widthToZoomRatio;\n}\n/**\n * For a given x position (leftOffset) in pixels, calculate time based on\n * timeline state (timeline width in px, canvas time range)\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @param {number} leftOffset\n * @returns {number}\n */\n\nfunction calculateTimeForXPosition(canvasTimeStart, canvasTimeEnd, canvasWidth, leftOffset) {\n  var timeToPxRatio = (canvasTimeEnd - canvasTimeStart) / canvasWidth;\n  var timeFromCanvasTimeStart = timeToPxRatio * leftOffset;\n  return timeFromCanvasTimeStart + canvasTimeStart;\n}\nfunction iterateTimes(start, end, unit, timeSteps, callback) {\n  var time = (0, _moment[\"default\"])(start).startOf(unit);\n  if (timeSteps[unit] && timeSteps[unit] > 1) {\n    var value = time.get(unit);\n    time.set(unit, value - value % timeSteps[unit]);\n  }\n  while (time.valueOf() < end) {\n    var nextTime = (0, _moment[\"default\"])(time).add(timeSteps[unit] || 1, \"\".concat(unit, \"s\"));\n    callback(time, nextTime);\n    time = nextTime;\n  }\n} // this function is VERY HOT as its used in Timeline.js render function\n// TODO: check if there are performance implications here\n// when \"weeks\" feature is implemented, this function will be modified heavily\n\n/** determine the current rendered time unit based on timeline time span\n *\n * zoom: (in milliseconds) difference between time start and time end of timeline canvas\n * width: (in pixels) pixel width of timeline canvas\n * timeSteps: map of timeDividers with number to indicate step of each divider\n */\n// the smallest cell we want to render is 17px\n// this can be manipulated to make the breakpoints change more/less\n// i.e. on zoom how often do we switch to the next unit of time\n// i think this is the distance between cell lines\n\nvar minCellWidth = 17;\nexports.minCellWidth = minCellWidth;\nfunction getMinUnit(zoom, width, timeSteps) {\n  // for supporting weeks, its important to remember that each of these\n  // units has a natural progression to the other. i.e. a year is 12 months\n  // a month is 24 days, a day is 24 hours.\n  // with weeks this isnt the case so weeks needs to be handled specially\n  var timeDividers = {\n    second: 1000,\n    minute: 60,\n    hour: 60,\n    day: 24,\n    month: 30,\n    year: 12\n  };\n  var minUnit = 'year'; // this timespan is in ms initially\n\n  var nextTimeSpanInUnitContext = zoom;\n  Object.keys(timeDividers).some(function (unit) {\n    // converts previous time span to current unit\n    // (e.g. milliseconds to seconds, seconds to minutes, etc)\n    nextTimeSpanInUnitContext = nextTimeSpanInUnitContext / timeDividers[unit]; // timeSteps is \"\n    // With what step to display different units. E.g. 15 for minute means only minutes 0, 15, 30 and 45 will be shown.\"\n    // how many cells would be rendered given this time span, for this unit?\n    // e.g. for time span of 60 minutes, and time step of 1, we would render 60 cells\n\n    var cellsToBeRenderedForCurrentUnit = nextTimeSpanInUnitContext / timeSteps[unit]; // what is happening here? why 3 if time steps are greater than 1??\n\n    var cellWidthToUse = timeSteps[unit] && timeSteps[unit] > 1 ? 3 * minCellWidth : minCellWidth; // for the minWidth of a cell, how many cells would be rendered given\n    // the current pixel width\n    // i.e. f\n\n    var minimumCellsToRenderUnit = width / cellWidthToUse;\n    if (cellsToBeRenderedForCurrentUnit < minimumCellsToRenderUnit) {\n      // for the current zoom, the number of cells we'd need to render all parts of this unit\n      // is less than the minimum number of cells needed at minimum cell width\n      minUnit = unit;\n      return true;\n    }\n  });\n  return minUnit;\n}\nfunction getNextUnit(unit) {\n  var nextUnits = {\n    second: 'minute',\n    minute: 'hour',\n    hour: 'day',\n    day: 'month',\n    month: 'year',\n    year: 'year'\n  };\n  if (!nextUnits[unit]) {\n    throw new Error(\"unit \".concat(unit, \" in not acceptable\"));\n  }\n  return nextUnits[unit];\n}\n/**\n * get the new start and new end time of item that is being\n * dragged or resized\n * @param {*} itemTimeStart original item time in milliseconds\n * @param {*} itemTimeEnd original item time in milliseconds\n * @param {*} dragTime new start time if item is dragged in milliseconds\n * @param {*} isDragging is item being dragged\n * @param {*} isResizing is item being resized\n * @param {`right` or `left`} resizingEdge resize edge\n * @param {*} resizeTime new resize time in milliseconds\n */\n\nfunction calculateInteractionNewTimes(_ref) {\n  var itemTimeStart = _ref.itemTimeStart,\n    itemTimeEnd = _ref.itemTimeEnd,\n    dragTime = _ref.dragTime,\n    isDragging = _ref.isDragging,\n    isResizing = _ref.isResizing,\n    resizingEdge = _ref.resizingEdge,\n    resizeTime = _ref.resizeTime;\n  var originalItemRange = itemTimeEnd - itemTimeStart;\n  var itemStart = isResizing && resizingEdge === 'left' ? resizeTime : itemTimeStart;\n  var itemEnd = isResizing && resizingEdge === 'right' ? resizeTime : itemTimeEnd;\n  return [isDragging ? dragTime : itemStart, isDragging ? dragTime + originalItemRange : itemEnd];\n}\nfunction calculateDimensions(_ref2) {\n  var itemTimeStart = _ref2.itemTimeStart,\n    itemTimeEnd = _ref2.itemTimeEnd,\n    canvasTimeStart = _ref2.canvasTimeStart,\n    canvasTimeEnd = _ref2.canvasTimeEnd,\n    canvasWidth = _ref2.canvasWidth;\n  var itemTimeRange = itemTimeEnd - itemTimeStart; // restrict startTime and endTime to be bounded by canvasTimeStart and canvasTimeEnd\n\n  var effectiveStartTime = Math.max(itemTimeStart, canvasTimeStart);\n  var effectiveEndTime = Math.min(itemTimeEnd, canvasTimeEnd);\n  var left = calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, effectiveStartTime);\n  var right = calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, effectiveEndTime);\n  var itemWidth = right - left;\n  var dimensions = {\n    left: left,\n    width: Math.max(itemWidth, 3),\n    collisionLeft: itemTimeStart,\n    collisionWidth: itemTimeRange\n  };\n  return dimensions;\n}\n/**\n * Get the order of groups based on their keys\n * @param {*} groups array of groups\n * @param {*} keys the keys object\n * @returns Ordered hash of objects with their array index and group\n */\n\nfunction getGroupOrders(groups, keys) {\n  var groupIdKey = keys.groupIdKey;\n  var groupOrders = {};\n  for (var i = 0; i < groups.length; i++) {\n    groupOrders[(0, _generic._get)(groups[i], groupIdKey)] = {\n      index: i,\n      group: groups[i]\n    };\n  }\n  return groupOrders;\n}\n/**\n * Adds items relevant to each group to the result of getGroupOrders\n * @param {*} items list of all items\n * @param {*} groupOrders the result of getGroupOrders\n */\n\nfunction getGroupedItems(items, groupOrders) {\n  var groupedItems = {};\n  var keys = Object.keys(groupOrders); // Initialize with result object for each group\n\n  for (var i = 0; i < keys.length; i++) {\n    var groupOrder = groupOrders[keys[i]];\n    groupedItems[i] = {\n      index: groupOrder.index,\n      group: groupOrder.group,\n      items: []\n    };\n  } // Populate groups\n\n  for (var _i = 0; _i < items.length; _i++) {\n    if (items[_i].dimensions.order !== undefined) {\n      var groupItem = groupedItems[items[_i].dimensions.order.index];\n      if (groupItem) {\n        groupItem.items.push(items[_i]);\n      }\n    }\n  }\n  return groupedItems;\n}\nfunction getVisibleItems(items, canvasTimeStart, canvasTimeEnd, keys) {\n  var itemTimeStartKey = keys.itemTimeStartKey,\n    itemTimeEndKey = keys.itemTimeEndKey;\n  return items.filter(function (item) {\n    return (0, _generic._get)(item, itemTimeStartKey) <= canvasTimeEnd && (0, _generic._get)(item, itemTimeEndKey) >= canvasTimeStart;\n  });\n}\nvar EPSILON = 0.001;\nfunction collision(a, b, lineHeight) {\n  var collisionPadding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EPSILON;\n  // 2d collisions detection - https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\n  var verticalMargin = 0;\n  return a.collisionLeft + collisionPadding < b.collisionLeft + b.collisionWidth && a.collisionLeft + a.collisionWidth - collisionPadding > b.collisionLeft && a.top - verticalMargin + collisionPadding < b.top + b.height && a.top + a.height + verticalMargin - collisionPadding > b.top;\n}\n/**\n * Calculate the position of a given item for a group that\n * is being stacked\n */\n\nfunction groupStack(lineHeight, item, group, groupHeight, groupTop, itemIndex) {\n  // calculate non-overlapping positions\n  var curHeight = groupHeight;\n  var verticalMargin = (lineHeight - item.dimensions.height) / 2;\n  if (item.dimensions.stack && item.dimensions.top === null) {\n    item.dimensions.top = groupTop + verticalMargin;\n    curHeight = Math.max(curHeight, lineHeight);\n    do {\n      var collidingItem = null; //Items are placed from i=0 onwards, only check items with index < i\n\n      for (var j = itemIndex - 1, jj = 0; j >= jj; j--) {\n        var other = group[j];\n        if (other.dimensions.top !== null && other.dimensions.stack && collision(item.dimensions, other.dimensions, lineHeight)) {\n          collidingItem = other;\n          break;\n        } else {// console.log('dont test', other.top !== null, other !== item, other.stack);\n        }\n      }\n      if (collidingItem != null) {\n        // There is a collision. Reposition the items above the colliding element\n        item.dimensions.top = collidingItem.dimensions.top + lineHeight;\n        curHeight = Math.max(curHeight, item.dimensions.top + item.dimensions.height + verticalMargin - groupTop);\n      }\n    } while (collidingItem);\n  }\n  return {\n    groupHeight: curHeight,\n    verticalMargin: verticalMargin,\n    itemTop: item.dimensions.top\n  };\n} // Calculate the position of this item for a group that is not being stacked\n\nfunction groupNoStack(lineHeight, item, groupHeight, groupTop) {\n  var verticalMargin = (lineHeight - item.dimensions.height) / 2;\n  if (item.dimensions.top === null) {\n    item.dimensions.top = groupTop + verticalMargin;\n    groupHeight = Math.max(groupHeight, lineHeight);\n  }\n  return {\n    groupHeight: groupHeight,\n    verticalMargin: 0,\n    itemTop: item.dimensions.top\n  };\n}\nfunction sum() {\n  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return arr.reduce(function (acc, i) {\n    return acc + i;\n  }, 0);\n}\n/**\n * Stack all groups\n * @param {*} items items to be stacked\n * @param {*} groupOrders the groupOrders object\n * @param {*} lineHeight\n * @param {*} stackItems should items be stacked?\n */\n\nfunction stackAll(itemsDimensions, groupOrders, lineHeight, stackItems) {\n  var groupHeights = [];\n  var groupTops = [];\n  var groupedItems = getGroupedItems(itemsDimensions, groupOrders);\n  for (var index in groupedItems) {\n    var groupItems = groupedItems[index];\n    var _itemsDimensions = groupItems.items,\n      group = groupItems.group;\n    var groupTop = sum(groupHeights); // Is group being stacked?\n\n    var isGroupStacked = group.stackItems !== undefined ? group.stackItems : stackItems;\n    var _stackGroup = stackGroup(_itemsDimensions, isGroupStacked, lineHeight, groupTop),\n      groupHeight = _stackGroup.groupHeight; // If group height is overridden, push new height\n    // Do this late as item position still needs to be calculated\n\n    groupTops.push(groupTop);\n    if (group.height) {\n      groupHeights.push(group.height);\n    } else {\n      groupHeights.push(Math.max(groupHeight, lineHeight));\n    }\n  }\n  return {\n    height: sum(groupHeights),\n    groupHeights: groupHeights,\n    groupTops: groupTops\n  };\n}\n/**\n * \n * @param {*} itemsDimensions \n * @param {*} isGroupStacked \n * @param {*} lineHeight \n * @param {*} groupTop \n */\n\nfunction stackGroup(itemsDimensions, isGroupStacked, lineHeight, groupTop) {\n  var groupHeight = 0;\n  var verticalMargin = 0; // Find positions for each item in group\n\n  for (var itemIndex = 0; itemIndex < itemsDimensions.length; itemIndex++) {\n    var r = {};\n    if (isGroupStacked) {\n      r = groupStack(lineHeight, itemsDimensions[itemIndex], itemsDimensions, groupHeight, groupTop, itemIndex);\n    } else {\n      r = groupNoStack(lineHeight, itemsDimensions[itemIndex], groupHeight, groupTop);\n    }\n    groupHeight = r.groupHeight;\n    verticalMargin = r.verticalMargin;\n  }\n  return {\n    groupHeight: groupHeight,\n    verticalMargin: verticalMargin\n  };\n}\n/**\n * Stack the items that will be visible\n * within the canvas area\n * @param {item[]} items\n * @param {group[]} groups\n * @param {number} canvasWidth\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {*} keys\n * @param {number} lineHeight\n * @param {number} itemHeightRatio\n * @param {boolean} stackItems\n * @param {*} draggingItem\n * @param {*} resizingItem\n * @param {number} dragTime\n * @param {left or right} resizingEdge\n * @param {number} resizeTime\n * @param {number} newGroupOrder\n */\n\nfunction stackTimelineItems(items, groups, canvasWidth, canvasTimeStart, canvasTimeEnd, keys, lineHeight, itemHeightRatio, stackItems, draggingItem, resizingItem, dragTime, resizingEdge, resizeTime, newGroupOrder) {\n  var visibleItems = getVisibleItems(items, canvasTimeStart, canvasTimeEnd, keys);\n  var visibleItemsWithInteraction = visibleItems.map(function (item) {\n    return getItemWithInteractions({\n      item: item,\n      keys: keys,\n      draggingItem: draggingItem,\n      resizingItem: resizingItem,\n      dragTime: dragTime,\n      resizingEdge: resizingEdge,\n      resizeTime: resizeTime,\n      groups: groups,\n      newGroupOrder: newGroupOrder\n    });\n  }); // if there are no groups return an empty array of dimensions\n\n  if (groups.length === 0) {\n    return {\n      dimensionItems: [],\n      height: 0,\n      groupHeights: [],\n      groupTops: []\n    };\n  } // Get the order of groups based on their id key\n\n  var groupOrders = getGroupOrders(groups, keys);\n  var dimensionItems = visibleItemsWithInteraction.map(function (item) {\n    return getItemDimensions({\n      item: item,\n      keys: keys,\n      canvasTimeStart: canvasTimeStart,\n      canvasTimeEnd: canvasTimeEnd,\n      canvasWidth: canvasWidth,\n      groupOrders: groupOrders,\n      lineHeight: lineHeight,\n      itemHeightRatio: itemHeightRatio\n    });\n  }).filter(function (item) {\n    return !!item;\n  }); // Get a new array of groupOrders holding the stacked items\n\n  var _stackAll = stackAll(dimensionItems, groupOrders, lineHeight, stackItems),\n    height = _stackAll.height,\n    groupHeights = _stackAll.groupHeights,\n    groupTops = _stackAll.groupTops;\n  return {\n    dimensionItems: dimensionItems,\n    height: height,\n    groupHeights: groupHeights,\n    groupTops: groupTops\n  };\n}\n/**\n * get canvas width from visible width\n * @param {*} width\n * @param {*} buffer\n */\n\nfunction getCanvasWidth(width, buffer) {\n  return width * buffer;\n}\n/**\n * get item's position, dimensions and collisions\n * @param {*} item\n * @param {*} keys\n * @param {*} canvasTimeStart\n * @param {*} canvasTimeEnd\n * @param {*} canvasWidth\n * @param {*} groupOrders\n * @param {*} lineHeight\n * @param {*} itemHeightRatio\n */\n\nfunction getItemDimensions(_ref3) {\n  var item = _ref3.item,\n    keys = _ref3.keys,\n    canvasTimeStart = _ref3.canvasTimeStart,\n    canvasTimeEnd = _ref3.canvasTimeEnd,\n    canvasWidth = _ref3.canvasWidth,\n    groupOrders = _ref3.groupOrders,\n    lineHeight = _ref3.lineHeight,\n    itemHeightRatio = _ref3.itemHeightRatio;\n  var itemId = (0, _generic._get)(item, keys.itemIdKey);\n  var dimension = calculateDimensions({\n    itemTimeStart: (0, _generic._get)(item, keys.itemTimeStartKey),\n    itemTimeEnd: (0, _generic._get)(item, keys.itemTimeEndKey),\n    canvasTimeStart: canvasTimeStart,\n    canvasTimeEnd: canvasTimeEnd,\n    canvasWidth: canvasWidth\n  });\n  if (dimension) {\n    dimension.top = null;\n    dimension.order = groupOrders[(0, _generic._get)(item, keys.itemGroupKey)];\n    dimension.stack = !item.isOverlay;\n    dimension.height = lineHeight * itemHeightRatio;\n    return {\n      id: itemId,\n      dimensions: dimension\n    };\n  }\n}\n/**\n * get new item with changed  `itemTimeStart` , `itemTimeEnd` and `itemGroupKey` according to user interaction\n * user interaction is dragging an item and resize left and right\n * @param {*} item\n * @param {*} keys\n * @param {*} draggingItem\n * @param {*} resizingItem\n * @param {*} dragTime\n * @param {*} resizingEdge\n * @param {*} resizeTime\n * @param {*} groups\n * @param {*} newGroupOrder\n */\n\nfunction getItemWithInteractions(_ref4) {\n  var _objectSpread2;\n  var item = _ref4.item,\n    keys = _ref4.keys,\n    draggingItem = _ref4.draggingItem,\n    resizingItem = _ref4.resizingItem,\n    dragTime = _ref4.dragTime,\n    resizingEdge = _ref4.resizingEdge,\n    resizeTime = _ref4.resizeTime,\n    groups = _ref4.groups,\n    newGroupOrder = _ref4.newGroupOrder;\n  if (!resizingItem && !draggingItem) return item;\n  var itemId = (0, _generic._get)(item, keys.itemIdKey);\n  var isDragging = itemId === draggingItem;\n  var isResizing = itemId === resizingItem;\n  var _calculateInteraction = calculateInteractionNewTimes({\n      itemTimeStart: (0, _generic._get)(item, keys.itemTimeStartKey),\n      itemTimeEnd: (0, _generic._get)(item, keys.itemTimeEndKey),\n      isDragging: isDragging,\n      isResizing: isResizing,\n      dragTime: dragTime,\n      resizingEdge: resizingEdge,\n      resizeTime: resizeTime\n    }),\n    _calculateInteraction2 = _slicedToArray(_calculateInteraction, 2),\n    itemTimeStart = _calculateInteraction2[0],\n    itemTimeEnd = _calculateInteraction2[1];\n  var newItem = _objectSpread({}, item, (_objectSpread2 = {}, _defineProperty(_objectSpread2, keys.itemTimeStartKey, itemTimeStart), _defineProperty(_objectSpread2, keys.itemTimeEndKey, itemTimeEnd), _defineProperty(_objectSpread2, keys.itemGroupKey, isDragging ? (0, _generic._get)(groups[newGroupOrder], keys.groupIdKey) : (0, _generic._get)(item, keys.itemGroupKey)), _objectSpread2));\n  return newItem;\n}\n/**\n * get canvas start and end time from visible start and end time\n * @param {number} visibleTimeStart\n * @param {number} visibleTimeEnd\n */\n\nfunction getCanvasBoundariesFromVisibleTime(visibleTimeStart, visibleTimeEnd, buffer) {\n  var zoom = visibleTimeEnd - visibleTimeStart; // buffer - 1 (1 is visible area) divided by 2 (2 is the buffer split on the right and left of the timeline)\n\n  var canvasTimeStart = visibleTimeStart - zoom * (buffer - 1) / 2;\n  var canvasTimeEnd = canvasTimeStart + zoom * buffer;\n  return [canvasTimeStart, canvasTimeEnd];\n}\n/**\n * Get the the canvas area for a given visible time\n * Will shift the start/end of the canvas if the visible time\n * does not fit within the existing\n * @param {number} visibleTimeStart\n * @param {number} visibleTimeEnd\n * @param {boolean} forceUpdateDimensions\n * @param {*} items\n * @param {*} groups\n * @param {*} props\n * @param {*} state\n */\n\nfunction calculateScrollCanvas(visibleTimeStart, visibleTimeEnd, forceUpdateDimensions, items, groups, props, state) {\n  var buffer = props.buffer;\n  var oldCanvasTimeStart = state.canvasTimeStart;\n  var oldCanvasTimeEnd = state.canvasTimeEnd;\n  var oldZoom = state.visibleTimeEnd - state.visibleTimeStart;\n  var newZoom = visibleTimeEnd - visibleTimeStart;\n  var newState = {\n    visibleTimeStart: visibleTimeStart,\n    visibleTimeEnd: visibleTimeEnd // Check if the current canvas covers the new times\n  };\n  var canKeepCanvas = newZoom === oldZoom && visibleTimeStart >= oldCanvasTimeStart + oldZoom * 0.5 && visibleTimeStart <= oldCanvasTimeEnd - oldZoom * 1.5 && visibleTimeEnd >= oldCanvasTimeStart + oldZoom * 1.5 && visibleTimeEnd <= oldCanvasTimeEnd - oldZoom * 0.5;\n  if (!canKeepCanvas || forceUpdateDimensions) {\n    var _getCanvasBoundariesF = getCanvasBoundariesFromVisibleTime(visibleTimeStart, visibleTimeEnd, buffer),\n      _getCanvasBoundariesF2 = _slicedToArray(_getCanvasBoundariesF, 2),\n      canvasTimeStart = _getCanvasBoundariesF2[0],\n      canvasTimeEnd = _getCanvasBoundariesF2[1];\n    newState.canvasTimeStart = canvasTimeStart;\n    newState.canvasTimeEnd = canvasTimeEnd;\n    var mergedState = _objectSpread({}, state, {}, newState);\n    var canvasWidth = getCanvasWidth(mergedState.width, props.buffer); // The canvas cannot be kept, so calculate the new items position\n\n    Object.assign(newState, stackTimelineItems(items, groups, canvasWidth, mergedState.canvasTimeStart, mergedState.canvasTimeEnd, props.keys, props.lineHeight, props.itemHeightRatio, props.stackItems, mergedState.draggingItem, mergedState.resizingItem, mergedState.dragTime, mergedState.resizingEdge, mergedState.resizeTime, mergedState.newGroupOrder));\n  }\n  return newState;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","coordinateToTimeRatio","calculateXPositionForTime","calculateTimeForXPosition","iterateTimes","getMinUnit","getNextUnit","calculateInteractionNewTimes","calculateDimensions","getGroupOrders","getGroupedItems","getVisibleItems","collision","groupStack","groupNoStack","stackAll","stackGroup","stackTimelineItems","getCanvasWidth","getItemDimensions","getItemWithInteractions","getCanvasBoundariesFromVisibleTime","calculateScrollCanvas","minCellWidth","_moment","_interopRequireDefault","require","_generic","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","defineProperties","getOwnPropertyDescriptors","configurable","writable","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","err","Array","isArray","canvasTimeStart","canvasTimeEnd","canvasWidth","time","widthToZoomRatio","timeOffset","leftOffset","timeToPxRatio","timeFromCanvasTimeStart","start","end","unit","timeSteps","callback","startOf","get","set","valueOf","nextTime","add","zoom","width","timeDividers","second","minute","hour","day","month","year","minUnit","nextTimeSpanInUnitContext","some","cellsToBeRenderedForCurrentUnit","cellWidthToUse","minimumCellsToRenderUnit","nextUnits","Error","_ref","itemTimeStart","itemTimeEnd","dragTime","isDragging","isResizing","resizingEdge","resizeTime","originalItemRange","itemStart","itemEnd","_ref2","itemTimeRange","effectiveStartTime","Math","max","effectiveEndTime","min","left","right","itemWidth","dimensions","collisionLeft","collisionWidth","groups","groupIdKey","groupOrders","_get","index","group","items","groupedItems","groupOrder","order","groupItem","itemTimeStartKey","itemTimeEndKey","item","EPSILON","a","b","lineHeight","collisionPadding","verticalMargin","top","height","groupHeight","groupTop","itemIndex","curHeight","stack","collidingItem","j","jj","other","itemTop","sum","reduce","acc","itemsDimensions","stackItems","groupHeights","groupTops","groupItems","_itemsDimensions","isGroupStacked","_stackGroup","r","itemHeightRatio","draggingItem","resizingItem","newGroupOrder","visibleItems","visibleItemsWithInteraction","map","dimensionItems","_stackAll","buffer","_ref3","itemId","itemIdKey","dimension","itemGroupKey","isOverlay","id","_ref4","_objectSpread2","_calculateInteraction","_calculateInteraction2","newItem","visibleTimeStart","visibleTimeEnd","forceUpdateDimensions","props","state","oldCanvasTimeStart","oldCanvasTimeEnd","oldZoom","newZoom","newState","canKeepCanvas","_getCanvasBoundariesF","_getCanvasBoundariesF2","mergedState","assign"],"sources":["/Users/ethan/WebstormProjects/frontend/node_modules/react-calendar-timeline/lib/lib/utility/calendar.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coordinateToTimeRatio = coordinateToTimeRatio;\nexports.calculateXPositionForTime = calculateXPositionForTime;\nexports.calculateTimeForXPosition = calculateTimeForXPosition;\nexports.iterateTimes = iterateTimes;\nexports.getMinUnit = getMinUnit;\nexports.getNextUnit = getNextUnit;\nexports.calculateInteractionNewTimes = calculateInteractionNewTimes;\nexports.calculateDimensions = calculateDimensions;\nexports.getGroupOrders = getGroupOrders;\nexports.getGroupedItems = getGroupedItems;\nexports.getVisibleItems = getVisibleItems;\nexports.collision = collision;\nexports.groupStack = groupStack;\nexports.groupNoStack = groupNoStack;\nexports.stackAll = stackAll;\nexports.stackGroup = stackGroup;\nexports.stackTimelineItems = stackTimelineItems;\nexports.getCanvasWidth = getCanvasWidth;\nexports.getItemDimensions = getItemDimensions;\nexports.getItemWithInteractions = getItemWithInteractions;\nexports.getCanvasBoundariesFromVisibleTime = getCanvasBoundariesFromVisibleTime;\nexports.calculateScrollCanvas = calculateScrollCanvas;\nexports.minCellWidth = void 0;\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _generic = require(\"./generic\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Calculate the ms / pixel ratio of the timeline state\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @returns {number}\n */\nfunction coordinateToTimeRatio(canvasTimeStart, canvasTimeEnd, canvasWidth) {\n  return (canvasTimeEnd - canvasTimeStart) / canvasWidth;\n}\n/**\n * For a given time, calculate the pixel position given timeline state\n * (timeline width in px, canvas time range)\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @param {number} time\n * @returns {number}\n */\n\n\nfunction calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, time) {\n  var widthToZoomRatio = canvasWidth / (canvasTimeEnd - canvasTimeStart);\n  var timeOffset = time - canvasTimeStart;\n  return timeOffset * widthToZoomRatio;\n}\n/**\n * For a given x position (leftOffset) in pixels, calculate time based on\n * timeline state (timeline width in px, canvas time range)\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @param {number} leftOffset\n * @returns {number}\n */\n\n\nfunction calculateTimeForXPosition(canvasTimeStart, canvasTimeEnd, canvasWidth, leftOffset) {\n  var timeToPxRatio = (canvasTimeEnd - canvasTimeStart) / canvasWidth;\n  var timeFromCanvasTimeStart = timeToPxRatio * leftOffset;\n  return timeFromCanvasTimeStart + canvasTimeStart;\n}\n\nfunction iterateTimes(start, end, unit, timeSteps, callback) {\n  var time = (0, _moment[\"default\"])(start).startOf(unit);\n\n  if (timeSteps[unit] && timeSteps[unit] > 1) {\n    var value = time.get(unit);\n    time.set(unit, value - value % timeSteps[unit]);\n  }\n\n  while (time.valueOf() < end) {\n    var nextTime = (0, _moment[\"default\"])(time).add(timeSteps[unit] || 1, \"\".concat(unit, \"s\"));\n    callback(time, nextTime);\n    time = nextTime;\n  }\n} // this function is VERY HOT as its used in Timeline.js render function\n// TODO: check if there are performance implications here\n// when \"weeks\" feature is implemented, this function will be modified heavily\n\n/** determine the current rendered time unit based on timeline time span\n *\n * zoom: (in milliseconds) difference between time start and time end of timeline canvas\n * width: (in pixels) pixel width of timeline canvas\n * timeSteps: map of timeDividers with number to indicate step of each divider\n */\n// the smallest cell we want to render is 17px\n// this can be manipulated to make the breakpoints change more/less\n// i.e. on zoom how often do we switch to the next unit of time\n// i think this is the distance between cell lines\n\n\nvar minCellWidth = 17;\nexports.minCellWidth = minCellWidth;\n\nfunction getMinUnit(zoom, width, timeSteps) {\n  // for supporting weeks, its important to remember that each of these\n  // units has a natural progression to the other. i.e. a year is 12 months\n  // a month is 24 days, a day is 24 hours.\n  // with weeks this isnt the case so weeks needs to be handled specially\n  var timeDividers = {\n    second: 1000,\n    minute: 60,\n    hour: 60,\n    day: 24,\n    month: 30,\n    year: 12\n  };\n  var minUnit = 'year'; // this timespan is in ms initially\n\n  var nextTimeSpanInUnitContext = zoom;\n  Object.keys(timeDividers).some(function (unit) {\n    // converts previous time span to current unit\n    // (e.g. milliseconds to seconds, seconds to minutes, etc)\n    nextTimeSpanInUnitContext = nextTimeSpanInUnitContext / timeDividers[unit]; // timeSteps is \"\n    // With what step to display different units. E.g. 15 for minute means only minutes 0, 15, 30 and 45 will be shown.\"\n    // how many cells would be rendered given this time span, for this unit?\n    // e.g. for time span of 60 minutes, and time step of 1, we would render 60 cells\n\n    var cellsToBeRenderedForCurrentUnit = nextTimeSpanInUnitContext / timeSteps[unit]; // what is happening here? why 3 if time steps are greater than 1??\n\n    var cellWidthToUse = timeSteps[unit] && timeSteps[unit] > 1 ? 3 * minCellWidth : minCellWidth; // for the minWidth of a cell, how many cells would be rendered given\n    // the current pixel width\n    // i.e. f\n\n    var minimumCellsToRenderUnit = width / cellWidthToUse;\n\n    if (cellsToBeRenderedForCurrentUnit < minimumCellsToRenderUnit) {\n      // for the current zoom, the number of cells we'd need to render all parts of this unit\n      // is less than the minimum number of cells needed at minimum cell width\n      minUnit = unit;\n      return true;\n    }\n  });\n  return minUnit;\n}\n\nfunction getNextUnit(unit) {\n  var nextUnits = {\n    second: 'minute',\n    minute: 'hour',\n    hour: 'day',\n    day: 'month',\n    month: 'year',\n    year: 'year'\n  };\n\n  if (!nextUnits[unit]) {\n    throw new Error(\"unit \".concat(unit, \" in not acceptable\"));\n  }\n\n  return nextUnits[unit];\n}\n/**\n * get the new start and new end time of item that is being\n * dragged or resized\n * @param {*} itemTimeStart original item time in milliseconds\n * @param {*} itemTimeEnd original item time in milliseconds\n * @param {*} dragTime new start time if item is dragged in milliseconds\n * @param {*} isDragging is item being dragged\n * @param {*} isResizing is item being resized\n * @param {`right` or `left`} resizingEdge resize edge\n * @param {*} resizeTime new resize time in milliseconds\n */\n\n\nfunction calculateInteractionNewTimes(_ref) {\n  var itemTimeStart = _ref.itemTimeStart,\n      itemTimeEnd = _ref.itemTimeEnd,\n      dragTime = _ref.dragTime,\n      isDragging = _ref.isDragging,\n      isResizing = _ref.isResizing,\n      resizingEdge = _ref.resizingEdge,\n      resizeTime = _ref.resizeTime;\n  var originalItemRange = itemTimeEnd - itemTimeStart;\n  var itemStart = isResizing && resizingEdge === 'left' ? resizeTime : itemTimeStart;\n  var itemEnd = isResizing && resizingEdge === 'right' ? resizeTime : itemTimeEnd;\n  return [isDragging ? dragTime : itemStart, isDragging ? dragTime + originalItemRange : itemEnd];\n}\n\nfunction calculateDimensions(_ref2) {\n  var itemTimeStart = _ref2.itemTimeStart,\n      itemTimeEnd = _ref2.itemTimeEnd,\n      canvasTimeStart = _ref2.canvasTimeStart,\n      canvasTimeEnd = _ref2.canvasTimeEnd,\n      canvasWidth = _ref2.canvasWidth;\n  var itemTimeRange = itemTimeEnd - itemTimeStart; // restrict startTime and endTime to be bounded by canvasTimeStart and canvasTimeEnd\n\n  var effectiveStartTime = Math.max(itemTimeStart, canvasTimeStart);\n  var effectiveEndTime = Math.min(itemTimeEnd, canvasTimeEnd);\n  var left = calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, effectiveStartTime);\n  var right = calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, effectiveEndTime);\n  var itemWidth = right - left;\n  var dimensions = {\n    left: left,\n    width: Math.max(itemWidth, 3),\n    collisionLeft: itemTimeStart,\n    collisionWidth: itemTimeRange\n  };\n  return dimensions;\n}\n/**\n * Get the order of groups based on their keys\n * @param {*} groups array of groups\n * @param {*} keys the keys object\n * @returns Ordered hash of objects with their array index and group\n */\n\n\nfunction getGroupOrders(groups, keys) {\n  var groupIdKey = keys.groupIdKey;\n  var groupOrders = {};\n\n  for (var i = 0; i < groups.length; i++) {\n    groupOrders[(0, _generic._get)(groups[i], groupIdKey)] = {\n      index: i,\n      group: groups[i]\n    };\n  }\n\n  return groupOrders;\n}\n/**\n * Adds items relevant to each group to the result of getGroupOrders\n * @param {*} items list of all items\n * @param {*} groupOrders the result of getGroupOrders\n */\n\n\nfunction getGroupedItems(items, groupOrders) {\n  var groupedItems = {};\n  var keys = Object.keys(groupOrders); // Initialize with result object for each group\n\n  for (var i = 0; i < keys.length; i++) {\n    var groupOrder = groupOrders[keys[i]];\n    groupedItems[i] = {\n      index: groupOrder.index,\n      group: groupOrder.group,\n      items: []\n    };\n  } // Populate groups\n\n\n  for (var _i = 0; _i < items.length; _i++) {\n    if (items[_i].dimensions.order !== undefined) {\n      var groupItem = groupedItems[items[_i].dimensions.order.index];\n\n      if (groupItem) {\n        groupItem.items.push(items[_i]);\n      }\n    }\n  }\n\n  return groupedItems;\n}\n\nfunction getVisibleItems(items, canvasTimeStart, canvasTimeEnd, keys) {\n  var itemTimeStartKey = keys.itemTimeStartKey,\n      itemTimeEndKey = keys.itemTimeEndKey;\n  return items.filter(function (item) {\n    return (0, _generic._get)(item, itemTimeStartKey) <= canvasTimeEnd && (0, _generic._get)(item, itemTimeEndKey) >= canvasTimeStart;\n  });\n}\n\nvar EPSILON = 0.001;\n\nfunction collision(a, b, lineHeight) {\n  var collisionPadding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EPSILON;\n  // 2d collisions detection - https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\n  var verticalMargin = 0;\n  return a.collisionLeft + collisionPadding < b.collisionLeft + b.collisionWidth && a.collisionLeft + a.collisionWidth - collisionPadding > b.collisionLeft && a.top - verticalMargin + collisionPadding < b.top + b.height && a.top + a.height + verticalMargin - collisionPadding > b.top;\n}\n/**\n * Calculate the position of a given item for a group that\n * is being stacked\n */\n\n\nfunction groupStack(lineHeight, item, group, groupHeight, groupTop, itemIndex) {\n  // calculate non-overlapping positions\n  var curHeight = groupHeight;\n  var verticalMargin = (lineHeight - item.dimensions.height) / 2;\n\n  if (item.dimensions.stack && item.dimensions.top === null) {\n    item.dimensions.top = groupTop + verticalMargin;\n    curHeight = Math.max(curHeight, lineHeight);\n\n    do {\n      var collidingItem = null; //Items are placed from i=0 onwards, only check items with index < i\n\n      for (var j = itemIndex - 1, jj = 0; j >= jj; j--) {\n        var other = group[j];\n\n        if (other.dimensions.top !== null && other.dimensions.stack && collision(item.dimensions, other.dimensions, lineHeight)) {\n          collidingItem = other;\n          break;\n        } else {// console.log('dont test', other.top !== null, other !== item, other.stack);\n        }\n      }\n\n      if (collidingItem != null) {\n        // There is a collision. Reposition the items above the colliding element\n        item.dimensions.top = collidingItem.dimensions.top + lineHeight;\n        curHeight = Math.max(curHeight, item.dimensions.top + item.dimensions.height + verticalMargin - groupTop);\n      }\n    } while (collidingItem);\n  }\n\n  return {\n    groupHeight: curHeight,\n    verticalMargin: verticalMargin,\n    itemTop: item.dimensions.top\n  };\n} // Calculate the position of this item for a group that is not being stacked\n\n\nfunction groupNoStack(lineHeight, item, groupHeight, groupTop) {\n  var verticalMargin = (lineHeight - item.dimensions.height) / 2;\n\n  if (item.dimensions.top === null) {\n    item.dimensions.top = groupTop + verticalMargin;\n    groupHeight = Math.max(groupHeight, lineHeight);\n  }\n\n  return {\n    groupHeight: groupHeight,\n    verticalMargin: 0,\n    itemTop: item.dimensions.top\n  };\n}\n\nfunction sum() {\n  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return arr.reduce(function (acc, i) {\n    return acc + i;\n  }, 0);\n}\n/**\n * Stack all groups\n * @param {*} items items to be stacked\n * @param {*} groupOrders the groupOrders object\n * @param {*} lineHeight\n * @param {*} stackItems should items be stacked?\n */\n\n\nfunction stackAll(itemsDimensions, groupOrders, lineHeight, stackItems) {\n  var groupHeights = [];\n  var groupTops = [];\n  var groupedItems = getGroupedItems(itemsDimensions, groupOrders);\n\n  for (var index in groupedItems) {\n    var groupItems = groupedItems[index];\n    var _itemsDimensions = groupItems.items,\n        group = groupItems.group;\n    var groupTop = sum(groupHeights); // Is group being stacked?\n\n    var isGroupStacked = group.stackItems !== undefined ? group.stackItems : stackItems;\n\n    var _stackGroup = stackGroup(_itemsDimensions, isGroupStacked, lineHeight, groupTop),\n        groupHeight = _stackGroup.groupHeight; // If group height is overridden, push new height\n    // Do this late as item position still needs to be calculated\n\n\n    groupTops.push(groupTop);\n\n    if (group.height) {\n      groupHeights.push(group.height);\n    } else {\n      groupHeights.push(Math.max(groupHeight, lineHeight));\n    }\n  }\n\n  return {\n    height: sum(groupHeights),\n    groupHeights: groupHeights,\n    groupTops: groupTops\n  };\n}\n/**\n * \n * @param {*} itemsDimensions \n * @param {*} isGroupStacked \n * @param {*} lineHeight \n * @param {*} groupTop \n */\n\n\nfunction stackGroup(itemsDimensions, isGroupStacked, lineHeight, groupTop) {\n  var groupHeight = 0;\n  var verticalMargin = 0; // Find positions for each item in group\n\n  for (var itemIndex = 0; itemIndex < itemsDimensions.length; itemIndex++) {\n    var r = {};\n\n    if (isGroupStacked) {\n      r = groupStack(lineHeight, itemsDimensions[itemIndex], itemsDimensions, groupHeight, groupTop, itemIndex);\n    } else {\n      r = groupNoStack(lineHeight, itemsDimensions[itemIndex], groupHeight, groupTop);\n    }\n\n    groupHeight = r.groupHeight;\n    verticalMargin = r.verticalMargin;\n  }\n\n  return {\n    groupHeight: groupHeight,\n    verticalMargin: verticalMargin\n  };\n}\n/**\n * Stack the items that will be visible\n * within the canvas area\n * @param {item[]} items\n * @param {group[]} groups\n * @param {number} canvasWidth\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {*} keys\n * @param {number} lineHeight\n * @param {number} itemHeightRatio\n * @param {boolean} stackItems\n * @param {*} draggingItem\n * @param {*} resizingItem\n * @param {number} dragTime\n * @param {left or right} resizingEdge\n * @param {number} resizeTime\n * @param {number} newGroupOrder\n */\n\n\nfunction stackTimelineItems(items, groups, canvasWidth, canvasTimeStart, canvasTimeEnd, keys, lineHeight, itemHeightRatio, stackItems, draggingItem, resizingItem, dragTime, resizingEdge, resizeTime, newGroupOrder) {\n  var visibleItems = getVisibleItems(items, canvasTimeStart, canvasTimeEnd, keys);\n  var visibleItemsWithInteraction = visibleItems.map(function (item) {\n    return getItemWithInteractions({\n      item: item,\n      keys: keys,\n      draggingItem: draggingItem,\n      resizingItem: resizingItem,\n      dragTime: dragTime,\n      resizingEdge: resizingEdge,\n      resizeTime: resizeTime,\n      groups: groups,\n      newGroupOrder: newGroupOrder\n    });\n  }); // if there are no groups return an empty array of dimensions\n\n  if (groups.length === 0) {\n    return {\n      dimensionItems: [],\n      height: 0,\n      groupHeights: [],\n      groupTops: []\n    };\n  } // Get the order of groups based on their id key\n\n\n  var groupOrders = getGroupOrders(groups, keys);\n  var dimensionItems = visibleItemsWithInteraction.map(function (item) {\n    return getItemDimensions({\n      item: item,\n      keys: keys,\n      canvasTimeStart: canvasTimeStart,\n      canvasTimeEnd: canvasTimeEnd,\n      canvasWidth: canvasWidth,\n      groupOrders: groupOrders,\n      lineHeight: lineHeight,\n      itemHeightRatio: itemHeightRatio\n    });\n  }).filter(function (item) {\n    return !!item;\n  }); // Get a new array of groupOrders holding the stacked items\n\n  var _stackAll = stackAll(dimensionItems, groupOrders, lineHeight, stackItems),\n      height = _stackAll.height,\n      groupHeights = _stackAll.groupHeights,\n      groupTops = _stackAll.groupTops;\n\n  return {\n    dimensionItems: dimensionItems,\n    height: height,\n    groupHeights: groupHeights,\n    groupTops: groupTops\n  };\n}\n/**\n * get canvas width from visible width\n * @param {*} width\n * @param {*} buffer\n */\n\n\nfunction getCanvasWidth(width, buffer) {\n  return width * buffer;\n}\n/**\n * get item's position, dimensions and collisions\n * @param {*} item\n * @param {*} keys\n * @param {*} canvasTimeStart\n * @param {*} canvasTimeEnd\n * @param {*} canvasWidth\n * @param {*} groupOrders\n * @param {*} lineHeight\n * @param {*} itemHeightRatio\n */\n\n\nfunction getItemDimensions(_ref3) {\n  var item = _ref3.item,\n      keys = _ref3.keys,\n      canvasTimeStart = _ref3.canvasTimeStart,\n      canvasTimeEnd = _ref3.canvasTimeEnd,\n      canvasWidth = _ref3.canvasWidth,\n      groupOrders = _ref3.groupOrders,\n      lineHeight = _ref3.lineHeight,\n      itemHeightRatio = _ref3.itemHeightRatio;\n  var itemId = (0, _generic._get)(item, keys.itemIdKey);\n  var dimension = calculateDimensions({\n    itemTimeStart: (0, _generic._get)(item, keys.itemTimeStartKey),\n    itemTimeEnd: (0, _generic._get)(item, keys.itemTimeEndKey),\n    canvasTimeStart: canvasTimeStart,\n    canvasTimeEnd: canvasTimeEnd,\n    canvasWidth: canvasWidth\n  });\n\n  if (dimension) {\n    dimension.top = null;\n    dimension.order = groupOrders[(0, _generic._get)(item, keys.itemGroupKey)];\n    dimension.stack = !item.isOverlay;\n    dimension.height = lineHeight * itemHeightRatio;\n    return {\n      id: itemId,\n      dimensions: dimension\n    };\n  }\n}\n/**\n * get new item with changed  `itemTimeStart` , `itemTimeEnd` and `itemGroupKey` according to user interaction\n * user interaction is dragging an item and resize left and right\n * @param {*} item\n * @param {*} keys\n * @param {*} draggingItem\n * @param {*} resizingItem\n * @param {*} dragTime\n * @param {*} resizingEdge\n * @param {*} resizeTime\n * @param {*} groups\n * @param {*} newGroupOrder\n */\n\n\nfunction getItemWithInteractions(_ref4) {\n  var _objectSpread2;\n\n  var item = _ref4.item,\n      keys = _ref4.keys,\n      draggingItem = _ref4.draggingItem,\n      resizingItem = _ref4.resizingItem,\n      dragTime = _ref4.dragTime,\n      resizingEdge = _ref4.resizingEdge,\n      resizeTime = _ref4.resizeTime,\n      groups = _ref4.groups,\n      newGroupOrder = _ref4.newGroupOrder;\n  if (!resizingItem && !draggingItem) return item;\n  var itemId = (0, _generic._get)(item, keys.itemIdKey);\n  var isDragging = itemId === draggingItem;\n  var isResizing = itemId === resizingItem;\n\n  var _calculateInteraction = calculateInteractionNewTimes({\n    itemTimeStart: (0, _generic._get)(item, keys.itemTimeStartKey),\n    itemTimeEnd: (0, _generic._get)(item, keys.itemTimeEndKey),\n    isDragging: isDragging,\n    isResizing: isResizing,\n    dragTime: dragTime,\n    resizingEdge: resizingEdge,\n    resizeTime: resizeTime\n  }),\n      _calculateInteraction2 = _slicedToArray(_calculateInteraction, 2),\n      itemTimeStart = _calculateInteraction2[0],\n      itemTimeEnd = _calculateInteraction2[1];\n\n  var newItem = _objectSpread({}, item, (_objectSpread2 = {}, _defineProperty(_objectSpread2, keys.itemTimeStartKey, itemTimeStart), _defineProperty(_objectSpread2, keys.itemTimeEndKey, itemTimeEnd), _defineProperty(_objectSpread2, keys.itemGroupKey, isDragging ? (0, _generic._get)(groups[newGroupOrder], keys.groupIdKey) : (0, _generic._get)(item, keys.itemGroupKey)), _objectSpread2));\n\n  return newItem;\n}\n/**\n * get canvas start and end time from visible start and end time\n * @param {number} visibleTimeStart\n * @param {number} visibleTimeEnd\n */\n\n\nfunction getCanvasBoundariesFromVisibleTime(visibleTimeStart, visibleTimeEnd, buffer) {\n  var zoom = visibleTimeEnd - visibleTimeStart; // buffer - 1 (1 is visible area) divided by 2 (2 is the buffer split on the right and left of the timeline)\n\n  var canvasTimeStart = visibleTimeStart - zoom * (buffer - 1) / 2;\n  var canvasTimeEnd = canvasTimeStart + zoom * buffer;\n  return [canvasTimeStart, canvasTimeEnd];\n}\n/**\n * Get the the canvas area for a given visible time\n * Will shift the start/end of the canvas if the visible time\n * does not fit within the existing\n * @param {number} visibleTimeStart\n * @param {number} visibleTimeEnd\n * @param {boolean} forceUpdateDimensions\n * @param {*} items\n * @param {*} groups\n * @param {*} props\n * @param {*} state\n */\n\n\nfunction calculateScrollCanvas(visibleTimeStart, visibleTimeEnd, forceUpdateDimensions, items, groups, props, state) {\n  var buffer = props.buffer;\n  var oldCanvasTimeStart = state.canvasTimeStart;\n  var oldCanvasTimeEnd = state.canvasTimeEnd;\n  var oldZoom = state.visibleTimeEnd - state.visibleTimeStart;\n  var newZoom = visibleTimeEnd - visibleTimeStart;\n  var newState = {\n    visibleTimeStart: visibleTimeStart,\n    visibleTimeEnd: visibleTimeEnd // Check if the current canvas covers the new times\n\n  };\n  var canKeepCanvas = newZoom === oldZoom && visibleTimeStart >= oldCanvasTimeStart + oldZoom * 0.5 && visibleTimeStart <= oldCanvasTimeEnd - oldZoom * 1.5 && visibleTimeEnd >= oldCanvasTimeStart + oldZoom * 1.5 && visibleTimeEnd <= oldCanvasTimeEnd - oldZoom * 0.5;\n\n  if (!canKeepCanvas || forceUpdateDimensions) {\n    var _getCanvasBoundariesF = getCanvasBoundariesFromVisibleTime(visibleTimeStart, visibleTimeEnd, buffer),\n        _getCanvasBoundariesF2 = _slicedToArray(_getCanvasBoundariesF, 2),\n        canvasTimeStart = _getCanvasBoundariesF2[0],\n        canvasTimeEnd = _getCanvasBoundariesF2[1];\n\n    newState.canvasTimeStart = canvasTimeStart;\n    newState.canvasTimeEnd = canvasTimeEnd;\n\n    var mergedState = _objectSpread({}, state, {}, newState);\n\n    var canvasWidth = getCanvasWidth(mergedState.width, props.buffer); // The canvas cannot be kept, so calculate the new items position\n\n    Object.assign(newState, stackTimelineItems(items, groups, canvasWidth, mergedState.canvasTimeStart, mergedState.canvasTimeEnd, props.keys, props.lineHeight, props.itemHeightRatio, props.stackItems, mergedState.draggingItem, mergedState.resizingItem, mergedState.dragTime, mergedState.resizingEdge, mergedState.resizeTime, mergedState.newGroupOrder));\n  }\n\n  return newState;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}